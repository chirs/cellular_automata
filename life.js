


//NEIGHBORS = [[0,0], [0,1], [-1,0], [0,-1], [1,0]]
NEIGHBORS = [[0,0], [0,1], [-1,1], [-1,0], [-1,-1], [0,-1], [1,-1], [1,0], [1,1]]
//NEIGHBORS = [[0,0], [0,1], [-1,1], [-1,0], [-1,-1], [0,-1], [1,-1], [1,0], [1,1]]
//NEIGHBORS = [[0,1], [2,0], [1,-3], [3, -1], [2, 2]]
//NEIGHBORS = [[0,0], [0,1], [-1,0], [0,-1], [1,0],[2,0], [3,0]]

//NEIGHBORS = [[1,0], [0,1], [-1,-1]]
//NEIGHBORS = [ [0,1], [-1,0], [0,-1], [1,0]]

// NEIGHBORS = [ [0,1], [-1,0], [0,-1], [1,0]], 10491




STATES = 2 // The number of possible states. Not currently used.

CELL_POSITIONS = Math.pow(STATES, NEIGHBORS.length) // The number of different arrangements a cell can be in. 
RULE_SETS = Math.pow(2, CELL_POSITIONS) // The number of mappings from a state to a state.


// Pick a random rule.
var randomRule = function(){
  return Math.floor(Math.random() * RULE_SETS)
}

var generateRule = function(ruleNumber){
  // Returns an array of the form [0,0,1,1,0,1...]
  var arr = ruleNumber.toString(2).split("").map( function(s){ return parseInt(s) } )
  while (arr.length < CELL_POSITIONS){ arr.unshift(0); } // left-fill with zeros.
  return arr
};


// Create an array with values generated by a callback.
var makeArray = function(dimensions, callback){
  var arr = []
  if (dimensions.length == 0){
    return arr;
  } else if (dimensions.length == 1){
    for (var i=0; i < dimensions[0]; i++){ arr.push(callback()) }
    return arr;
  } else {
    var arr = []
    for (var i=0; i<dimensions[0]; i++){
      arr.push(makeArray(dimensions.slice(1), callback));
    }
    return arr;
  }
}


var randomStart = function (dimensions, limit) {
  var f = function(){ if (Math.random() > limit) { return 1; } else { return 0; } }
  return makeArray(dimensions, f)
}


var canonicalStart = function(dimensions) {
  var a = makeArray(dimensions, function(){ return 0 })
  //var i = Math.floor(rows / 2)
  //var j = Math.floor(cols / 2)
  //a[i][j] = 1
  return a
}



// not quite right...
var makeIndexes = function(dimensions){
  var arr = []
  if (dimensions.length > 0){
    var sub = makeIndexes(dimensions.slice(1))
    console.log(sub)

    for (var i=0; i < dimensions[0]; i++){
      var index = sub.slice(0) // copy 
      index.unshift(i)
      arr.push(index)
    }
  }
  return arr;
}


var makeIndexes = function(dimensions){
  if (dimensions.length == 0){
    return [[]]
  } else {
    var arr = []
    for (var i=0; i < dimensions[0]; i++){
      var sub = makeIndexes(dimensions.slice(1));
      for (var j=0; j < sub.length; j++){
        var m = sub[j]
        m.unshift(i)
        arr.push(m)
      }
    }
    return arr
  }
}
      



// Get the dimensions of an array. e.g. [[[1,2,3], [2,3,4], [1,5,8]]] -> 3 (should this be [1,1,3]?)
// That is a bad example array.
var getDimensions = function(matrix){
  if (matrix.length == 0){
    return 0;
  } else {
    return 1 + getDimensions(matrix.slice(1));
  }
}

// This is actually summing two vectors.
// Used to identify node neighbors.
var getNeighbor = function(p1, p2){
  var d = getDimensions(p1)
  var l = []
  for (var i=0; i<d; i++){
    l.push(p1[i] + p2[i])
  }
  return l;
}


// Given a value like [1,4,7], pull those indexes from a nested array.
var getValue = function(p, table){
  if (p.length == 0){
    return table;
  } else {
    return getValue(p[0], table[p[0]])
  }
}



var getState = function(cell, table, rule){

  //var rows = table.length;
  //var cols = table[0].length

  //var getNeighbor = function(p1,p2){ return [(p1[0] + p2[0] + rows) % rows, (p1[1] + p2[1] + cols) % cols] }
  //var getValue = function(p){ return table[p[0]][p[1]] }

  var states = []
  for (i=0; i < NEIGHBORS.length; i++){
    var n = getNeighbor(cell, NEIGHBORS[i])
    var v = getValue(n);
    states.push(v)
  }

  var n = parseInt(states.join(""), 2)
  return rule[n]
}


// Need to iterate over whole table regardless of dimensions.
var generateNextState = function(table, n){
  var rule = generateRule(n);
  var l = [];
  var rows = table.length
  if (rows == 0){ return [] }
  var cols = table[0].length

  for (var i=0; i < rows; i++){
    var m = []
    for (var j=0; j < cols; j++){

      var state = getState([i,j], table, rule);
      m.push(state);
    }
    l.push(m);
    }
  return l
  }
  
                          

// n should be a number between 0 and 4294967296
// random -> randomly seeded board
var generator = function(dimensions, rule, random, density){
  if (random) {
    var history = [randomStart(dimensions, density)];
  } else {
    var history = [canonicalStart(dimensions)];
  }

  var state = function(){ return history[history.length-1] }
  

  return {
    state: state, 

    next: function(){
      var newState = generateNextState(state(), rule)
      history.push(newState)
      return newState
    },

  }
}








