// An implementation of the Game of Life automaton.
// Pretty sure this is just a 2-d elementary cellular automaton.
// http://en.wikipedia.org/wiki/Elementary_cellular_automaton
// http://en.wikipedia.org/wiki/Conway's_Game_of_Life


// We consider the Moore neighborhood only, 
// so there are 2 ** 5 possible states for an individual
// that makes 2^(2^5) = 4294967296 possible states.
// (Moore neighborhood give 2^(2^9)= 1.3407807929942597e+154 states)

// A rule is represented by a 32-digit binary number in the range [0, 2^(2^5)-1],
// equivalent to [ 0, 1111 1111 1111 1111 1111 1111 1111 1111 ]
// each digit in the number represents a transformation from 

// e.g. Rule 14 = 0000 1110
// maps to this state ordering:
//  [1,1,1] -> 0
//  [1,1,0] -> 0
//  [1,0,1] -> 0
//  [1,0,0] -> 0
//  [0,1,1] -> 1
//  [0,1,0] -> 1
//  [0,0,1] -> 1
//  [0,0,0] -> 1
// Possibly have this reversed.



// Select a random rule.
var randomRule = function(){
  return Math.floor(Math.random() * Math.pow(2, Math.pow(2, 5)))
}

// Create an array with values generated by f.
var makeArray = function(rows, cols, f){
  var xs
  var arr = []
  for (var i=0; i<rows; i++){
    xs = []
    for (var j=0; j<cols; j++){
      xs.push(f())
    }
    arr.push(xs)
  }
  return arr;
}



var randomStart = function (rows, cols, limit) {
  var f = function(arr){ if (Math.random() > limit) { return 1; } else { return 0; } }
  return makeArray(rows, cols, f)
}


var canonicalStart = function(rows, cols) {
  var f = function(arr){ return 0 }
  var a = makeArray(rows, cols, f)
  var i = Math.floor(rows / 2)
  var j = Math.floor(cols / 2)
  a[i][j] = 1
  return a
}


var generateRule = function(n){
  var l = n.toString(2).split("").map( function(s){ return parseInt(s) } )
  while (l.length < 32){ l.unshift(0); }

  return l
};

var getNext = function(l, m, r, rule){
  var s = [l,m,r].join("");
  var n = parseInt(s, 2);
  var i = 31 - n;
  return rule[i];
};


// Mirror a cell around the board.



var getState = function(cell, table, rule){
  //console.log(i)
  //console.log(j)
  //console.log(table)
  //console.log(rule)

  //console.log(table)

  var rows = table.length;
  var cols = table[0].length

  var neighbors = [[0,0], [1,0], [-1,0], [0,1], [0,-1]]
  var getNeighbor = function(p1,p2){ return [(p1[0] + p2[0] + rows) % rows, (p2[0] + p2[1] + cols) % cols] }
  var getValue = function(p){ return table[p[0]][p[1]] }

  var states = []
  for (i=0; i < neighbors.length; i++){
    var n = getNeighbor(cell, neighbors[i])
    var v = getValue(n);
    states.push(v)
  }

  var n = parseInt(states.join(""), 2)
  return table[n]
}




var generateNext = function(table, n){
  var rule = generateRule(n);
  var l = [];
  var rows = table.length
  if (rows == 0){ return [] }
  var cols = table[0].length

  for (var i=0; i < rows; i++){
    var m = []
    for (var j=0; j < cols; j++){
      //console.log("GNEXT ->") 
      //console.log(table);

      var state = getState([i,j], table, rule);
      m.push(state);
    }
    l.push(m);
    }
  return l
  }
  
                          

// n should be a number between 0 and 4294967296
// random -> randomly seeded board
var generator = function(rows, cols, rule, random, density){
  if (random) {
    var history = [randomStart(rows, cols, density)];
  } else {
    var history = [canonicalStart(rows, cols)];
  }

  var state = function(){ return history[history.length-1] }
  

  return {

    
    state: state, 

    next: function(){
      var newState = generateNext(state(), rule)
      history.push(newState)
      return newState
    },

  }
}


